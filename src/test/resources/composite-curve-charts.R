####################################################################
#
# Meant to be run on test data generated by the SFSeize project.
# This file generates images, also in the /tmp directory, that
# describe the behavior of different composite curves on a
# shared set of queries.
#
####################################################################

require("ggplot2")


####################################################################
#
# DATA PREPARATION
#
####################################################################

# load the raw data from the unit tests from a tab-separated file
df1 <- read.csv("/tmp/composed-curves.tsv", sep="\t")

# old unit-tests mixed data series; ensure that we are only
# using the subset that pertains to query ranges
queries <- subset(df1, df1[,2] == "ranges")

# create a new column that is the curve name plus parameters
queries$full.name <- paste(queries$curve, ": ", queries$precision, " bits", sep="")

# identify the top-level curve being used:
#   H:  (Compact) Hilbert
#   R:  Row-major
#   Z:  Z-order
queries$top.curve <- substr(queries$curve, 1, 1)

# point-size used for representing precision
queries$ptsize <- sqrt(queries$precision)

# filter out the 3D and 4D queries separately
q3d <- subset(queries, dimensions==3)
q4d <- subset(queries, dimensions==4)


####################################################################
#
# FUNCTIONS
#
####################################################################

# These charts show how different composites generate different
# numbers of ranges at different rates.

range.counts_vs_time <- function() {
  ggplot() + 
    ggtitle("4D space-filling curves:  range counts v. planning time") +
    ylab("mean planning time (seconds)") + xlab("mean number of contiguous ranges") +
    scale_x_log10() + scale_y_log10() +
    geom_line(data=q4d, aes(x=avgranges, y=seconds, group=curve, color=curve)) +
    geom_point(data=q4d, aes(x=avgranges, y=seconds, group=curve, color=curve, size=ptsize)) 
  ggsave(filename="/tmp/curves-4d.svg", width=16, height=5, units="in")
  
  ggplot() + 
    ggtitle("3D space-filling curves:  range counts v. planning time") +
    ylab("mean planning time (seconds)") + xlab("mean number of contiguous ranges") +
    scale_x_log10() + scale_y_log10() +
    geom_line(data=q3d, aes(x=avgranges, y=seconds, group=curve, color=curve)) +
    geom_point(data=q3d, aes(x=avgranges, y=seconds, group=curve, color=curve, size=ptsize)) 
  ggsave(filename="/tmp/curves-3d.svg", width=16, height=5, units="in")
}

# These charts are meant to illustrate the trade-off between the
# compactness of the query ranges (on average, how many cells did
# each range contain) versus throughput (on average, how many total
# cells did the query-ranges return per second).
#
# To aid interpretation, the charts are generated once for 4D (XYZT)
# curves, and once for 3D (XYT) curves.  Furthermore, the charts are
# faceted horizontally by the number of plys in the curve, and 
# vertically by the top-level space-filling curve in the composite.

compactness_vs_throughput <- function() {
  ggplot() +
    ggtitle("4D space-filling curves:  compactness v. throughput") +
    xlab("cells per range (compactness)") +
    ylab("cells per second (throughput)") + 
    geom_line(data=q4d, aes(x=cells.per.range, y=cells.per.second, group=curve, color=curve)) +
    scale_x_log10() + scale_y_log10() +
    facet_grid(top.curve ~ plys)
  ggsave(filename="/tmp/curves-4d-prorated.svg", width=30, height=16, units="in")
  
  ggplot() +
    ggtitle("3D space-filling curves:  compactness v. throughput") +
    xlab("cells per range (compactness)") +
    ylab("cells per second (throughput)") + 
    geom_line(data=q3d, aes(x=cells.per.range, y=cells.per.second, group=curve, color=curve)) +
    scale_x_log10() + scale_y_log10() +
    facet_grid(top.curve ~ plys)
  ggsave(filename="/tmp/curves-3d-prorated.svg", width=16, height=5, units="in")
}

# Generates the distribution of simple scores, ordering
# them from high to low.

score.plot <- function() {
  clean.data <- function(df.raw) {
    max.precision <- max(df.raw$precision)
    df.nums <- subset(df.raw, df.raw$score != Inf & df.raw$precision == max.precision)
    #df.nums <- subset(df.nums0, df.raw$precision == max.precision)
    idxs <- order(df.nums$score, decreasing=TRUE)
    df.clean <- df.nums[idxs,]
    df.clean$x <- 1:nrow(df.clean)
    return(df.clean)
  }
  
  df <- clean.data(q3d)
  y.max <- 10 ^ (floor(log10(max(df$score))) + 3.0)
  y.min <- 10 ^ (floor(log10(min(df$score))))
  ggplot() +
    ggtitle(paste("3D curve scores at", max(df$precision), "bits")) +
    scale_x_continuous(limits = c(0, nrow(df)+2, breaks=NULL)) +
    scale_y_log10(limits = c(y.min, y.max)) +
    geom_point(data=df, aes(x=x, y=score, group=full.name, color=curve), show_guide=FALSE) +
    geom_text(data=df, aes(legend=FALSE, x=x, y=score, label=curve, angle=45, size=1, hjust=-0.1, vjust=0), show_guide=FALSE) 
  ggsave(filename="/tmp/curves-3d-scores.svg", width=8, height=5, units="in")
  
  df <- clean.data(q4d)
  y.max <- 10 ^ (floor(log10(max(df$score))) + 3.0)
  y.min <- 10 ^ (floor(log10(min(df$score))))
  ggplot() +
    ggtitle(paste("4D curve scores at", max(df$precision), "bits")) +
    scale_x_continuous(limits = c(0, nrow(df)+2, breaks=NULL)) +
    scale_y_log10(limits = c(y.min, y.max)) +
    geom_point(data=df, aes(x=x, y=score, group=full.name, color=curve), show_guide=FALSE) +
    geom_text(data=df, aes(legend=FALSE, x=x, y=score, label=curve, angle=45, size=1, hjust=-0.1, vjust=0), show_guide=FALSE) 
  ggsave(filename="/tmp/curves-4d-scores.svg", width=20, height=5, units="in")
}


####################################################################
#
# MAIN PROGRAM
#
####################################################################

#range.counts_vs_time
compactness_vs_throughput()
score.plot()