####################################################################
#
# Meant to be run on test data generated by the SFSeize project.
# This file generates images, also in the /tmp directory, that
# describe the behavior of different composite curves on a
# shared set of queries.
#
####################################################################

require("ggplot2")
require("GGally")


####################################################################
#
# DATA PREPARATION
#
####################################################################

# load the raw data from the unit tests from a tab-separated file
df1 <- read.csv("/tmp/composed-curves.tsv", sep="\t")

# old unit-tests mixed data series; ensure that we are only
# using the subset that pertains to query ranges
queries <- subset(df1, df1[,2] == "ranges")

# create a new column that is the curve name plus parameters
queries$full.name <- paste(queries$curve, " ", queries$label, ": ", queries$precision, " bits", sep="")

# identify the top-level curve being used:
#   H:  (Compact) Hilbert
#   R:  Row-major
#   Z:  Z-order
queries$top.curve <- substr(queries$curve, 1, 1)

# disambiguate among the 3-ply variants
for (i in 1:nrow(queries)) {
  if (queries$plys[i] == 4) {
    queries$topology[i] = "(1,1,1,1)"
  } else {
    if (queries$plys[i] == 2) {
      queries$topology[i] = "(4)"
    } else {
      if (length(grep("x,y,z\\),t", queries$curve[i], ignore.case=TRUE, perl=TRUE)) == 1) {
        queries$topology[i] = "(3,1)"
      } else {
        queries$topology[i] = "(2,2)"
      }
    }
  }
}
queries$topology_f <- factor(queries$topology, levels=c("(1,1,1,1)", "(2,2)", "(3,1)", "(4)"), ordered=TRUE)

# point-size used for representing precision
queries$ptsize <- sqrt(queries$precision)

# create factors for chart labels
queries$curve_f = factor(queries$curve, levels=c(
  "H(H(H(x,y),z),t)", "H(H(R(x,y),z),t)", "H(H(x,y),H(z,t))", "H(H(x,y),R(z,t))", "H(H(x,y,z),t)", "H(H(x,y),Z(z,t))",
  "H(H(Z(x,y),z),t)", "H(R(H(x,y),z),t)", "H(R(R(x,y),z),t)", "H(R(x,y),H(z,t))", "H(R(x,y),R(z,t))", "H(R(x,y,z),t)",
  "H(R(x,y),Z(z,t))", "H(R(Z(x,y),z),t)", "H(x,y,z,t)", "H(Z(H(x,y),z),t)", "H(Z(R(x,y),z),t)", "H(Z(x,y),H(z,t))",
  "H(Z(x,y),R(z,t))", "H(Z(x,y,z),t)", "H(Z(x,y),Z(z,t))", "H(Z(Z(x,y),z),t)", "R(H(H(x,y),z),t)", "R(H(R(x,y),z),t)",
  "R(H(x,y),H(z,t))", "R(H(x,y),R(z,t))", "R(H(x,y,z),t)", "R(H(x,y),Z(z,t))", "R(H(Z(x,y),z),t)", "R(R(H(x,y),z),t)",
  "R(R(R(x,y),z),t)", "R(R(x,y),H(z,t))", "R(R(x,y),R(z,t))", "R(R(x,y,z),t)", "R(R(x,y),Z(z,t))", "R(R(Z(x,y),z),t)",
  "R(x,y,z,t)", "R(Z(H(x,y),z),t)", "R(Z(R(x,y),z),t)", "R(Z(x,y),H(z,t))", "R(Z(x,y),R(z,t))", "R(Z(x,y,z),t)",
  "R(Z(x,y),Z(z,t))", "R(Z(Z(x,y),z),t)", "Z(H(H(x,y),z),t)", "Z(H(R(x,y),z),t)", "Z(H(x,y),H(z,t))", "Z(H(x,y),R(z,t))",
  "Z(H(x,y,z),t)", "Z(H(x,y),Z(z,t))", "Z(H(Z(x,y),z),t)", "Z(R(H(x,y),z),t)", "Z(R(R(x,y),z),t)", "Z(R(x,y),H(z,t))",
  "Z(R(x,y),R(z,t))", "Z(R(x,y,z),t)", "Z(R(x,y),Z(z,t))", "Z(R(Z(x,y),z),t)", "Z(x,y,z,t)", "Z(Z(H(x,y),z),t)",
  "Z(Z(R(x,y),z),t)", "Z(Z(x,y),H(z,t))", "Z(Z(x,y),R(z,t))", "Z(Z(x,y,z),t)", "Z(Z(x,y),Z(z,t))", "Z(Z(Z(x,y),z),t)"
  ), ordered=TRUE)
queries$top.curve_f = factor(queries$top.curve, levels=c("R", "Z", "H"), ordered=TRUE)
queries$plys_f = factor(queries$plys, levels=c(2, 3, 4), labels=c("2-ply", "3-ply", "4-ply"), ordered=TRUE)
queries$label_f = factor(queries$label, levels=c("----", "---", "-YZT", "-YT", "X-ZT", "X-T", "XY-T", "XY-", "XYZ-", "XYT", "XYZT"), ordered=TRUE)
queries$seconds_f = factor(queries$seconds, levels=sort(unique(queries$seconds)), ordered=TRUE)

# filter out the 3D and 4D queries separately
q3d <- subset(queries, dimensions==3)
q4d <- subset(queries, dimensions==4)


####################################################################
#
# FUNCTIONS
#
####################################################################

# extracts the number of dimensions as a single string;
# expect "3D" (when homogeneous) or "3,4D" (when heterogeneous)

dimensions.string <- function(df) {
  paste(paste(sort(unique(df$dimensions)), collapse=","), "D", sep="")
}

# These charts are meant to illustrate the trade-off between the
# compactness of the query ranges (on average, how many cells did
# each range contain) versus throughput (on average, how many total
# cells did the query-ranges return per second).
#
# To aid interpretation, the charts are generated once for 4D (XYZT)
# curves, and once for 3D (XYT) curves.  Furthermore, the charts are
# faceted horizontally by the number of plys in the curve, and 
# vertically by the top-level space-filling curve in the composite.

compactness_vs_throughput <- function() {
  mk.chart <- function(df, width.inches, height.inches) {
    df <- subset(df, df$label != "----" & df$cells.per.second != Inf)
    df <- aggregate(df[,c("cells.per.range", "cells.per.second")], list(top.curve_f=df$top.curve_f, precision=df$precision, label=df$label, plys_f=df$plys_f, dimensions=df$dimensions), mean)
    df$series = paste(df$top.curve_f, df$label)
    dims <- dimensions.string(df)
    ggplot() +
      ggtitle(paste(dims, "compactness v. throughput")) +
      xlab("mean cells per range (compactness)") +
      ylab("mean cells per second (throughput)") + 
      geom_line(data=df, aes(x=cells.per.range, y=cells.per.second, group=series, color=series), show_guide=FALSE) +
      scale_x_log10() + scale_y_log10() +
      facet_grid(top.curve_f ~ plys_f)
    ggsave(filename=paste("/tmp/curves-", dims, "-prorated.png", sep=""), width=width.inches, height=height.inches, units="in")
  }
  
  mk.chart(q3d, 16.0, 5.0)
  mk.chart(q4d, 16.0, 5.0)
}

# Generates the distribution of simple scores, ordering
# them from high to low, having first grouped the runs
# by the curve topology.  The mean score per topology
# is reported.

score.plot <- function(score.label, score.column) {
  clean.data <- function(df.raw) {
    max.precision <- max(df.raw$precision)
    df.raw <- subset(df.raw, df.raw$precision == max.precision)
    score.range <- range(subset(df.raw[,score.column], df.raw[,score.column] != Inf))
    for (i in 1:nrow(df.raw)) {
      df.raw[i, score.column] <- ifelse(df.raw[i, score.column] == Inf, score.range[2]*10.0, df.raw[i, score.column])
    }
    df.nums <- subset(df.raw, df.raw[,score.column] != Inf & df.raw$precision == max.precision)
    df.nums$use.score <- df.nums[,score.column]
    df.nums <- aggregate(df.nums, list(curve = df.nums$curve, label=df.nums$label_f), mean)
    idxs <- order(df.nums$use.score, decreasing=TRUE)
    df.clean <- df.nums[idxs,]
    df.clean$idx <- 1:nrow(df.clean)
    df.clean$x <- 1:nrow(df.clean)
    labels <- unique(df.clean$label)
    for (i in 1:length(labels)) {
      subs <- subset(df.clean, df.clean$label == labels[i])
      idxs <- order(subs$use.score, decreasing=TRUE)
      for (j in 1:nrow(subs)) {
        df.clean$x[subs$idx[j]] <- idxs[j]
      }
    }
    return(df.clean)
  }
  
  mk.chart <- function(df.raw, width, height) {
    df <- clean.data(df.raw)
    dims <- dimensions.string(df)
    
    y.max <- 10 ^ (floor(log10(max(df$use.score))) + 3.0)
    y.min <- 10 ^ (floor(log10(min(df$use.score))))
    
    ggplot() +
      ggtitle(paste(dims, "curve", score.label, "scores at", max(df$precision), "bits, grouped by topology")) +
      scale_x_continuous(limits = c(0, range(df$x)[2]+2, breaks=NULL)) +
      scale_y_log10(limits = c(y.min, y.max)) +
      xlab(NULL) + ylab(paste(score.label, "score")) +
      geom_point(data=df, aes(x=x, y=use.score, group=curve, color=curve), show_guide=FALSE) +
      geom_text(data=df, aes(legend=FALSE, x=x, y=use.score, label=curve, angle=45, size=1, hjust=-0.1, vjust=0), show_guide=FALSE) +
      facet_grid(label ~ .)
    ggsave(filename=paste("/tmp/curves-", dims, "-", score.label, "-scores.png", sep=""), width=width, height=height, units="in")
  }
  
  mk.chart(q3d, 10.0, 25.0)
  mk.chart(q4d, 20.0, 20.0)
}


range.study.plot <- function(invert = FALSE) {
  mk.chart <- function(df.raw, width, height) {
    df <- df.raw
    df$top.curve_f = factor(df$top.curve, levels=c("R", "Z", "H"), ordered=TRUE)
    df$plys_f = factor(df$plys, levels=c(2, 3, 4), labels=c("2-ply", "3-ply", "4-ply"), ordered=TRUE)
    df$label_f = factor(df$label, levels=c("----", "-YZT", "X-ZT", "XY-T", "XYZ-", "XYZT"), ordered=TRUE)
    dims <- dimensions.string(df)

    df$y = rep(0.0, nrow(df))
    for (i in 1:nrow(df)) {
      df$y[i] <- ifelse(invert, 1.0 / max(0.000001, df$seconds[i]), df$seconds[i])
    }
      
    print(df)
    
    x.range <- range(df$avg.ranges)
    y.range <- range(df$y)
    if (invert) y.range <- rev(y.range)
    ref <- data.frame(x=x.range, y=y.range)
    print(ref)
    
    y.label <- ifelse(invert, "inverse seconds", "seconds")
    graph.name <- ifelse(invert, "ranges-inv", "ranges")
    
    ggplot() +
      ggtitle(paste(dims, "range study")) +
      scale_x_log10() +
      scale_y_log10() +
      xlab("number of ranges") + 
      ylab(y.label) +
      geom_line(data=ref, aes(x=x, y=y), lty="dotted", size=0.2) +
      geom_line(data=df, aes(x=avg.ranges, y=y, group=curve, color=curve), show_guide=FALSE) +
      facet_grid(label_f ~ top.curve_f + plys_f)
    ggsave(filename=paste("/tmp/", graph.name, "-", dims, ".png", sep=""), width=width, height=height, units="in")
  }
  
  mk.chart(q3d, 8.0, 5.0)
  mk.chart(q4d, 18.0, 12.0)
}


summary.parcoords <- function(df, width, height) {
  good.threshold <- 0.10
  
  max.precision = max(df$precision)
  df <- subset(df, df$precision == max.precision)

  seconds.range <- range(df$seconds)
  time.range.good <- paste("[", seconds.range[1], " to ", good.threshold, "]", sep="")
  time.range.bad <- paste("(", good.threshold, " to ", seconds.range[2], "]", sep="")
  df$seconds.color = "#000000"
  for (i in 1:nrow(df)) {
    df$seconds.color[i] = hsv(2.0 / 3.0 * (df$seconds[i] - seconds.range[1]) / (seconds.range[2] - seconds.range[1]), 0.8, 0.8)
  }
  df$seconds.color_f <- factor(ifelse(df$seconds <= good.threshold, time.range.good, time.range.bad), levels=c(time.range.good, time.range.bad), ordered=TRUE)
  
  dims <- dimensions.string(df)
  graph.name <- paste("parcoord-", dims, ".png", sep="")
  graph.title <- paste(dims, " queries at ", max.precision, " bits precision", sep="")
  
  colNames <- colnames(df)
  cols <- c(
    which(colNames == "curve"),
    which(colNames == "top.curve"),
    which(colNames == "topology"),
    which(colNames == "label"),
    which(colNames == "seconds"),
    which(colNames == "avg.ranges")
  )
  
  ggparcoord(
    data = df,
    columns = cols,
    scale = "uniminmax",
    #groupColumn = "seconds_f",
    groupColumn = "seconds.color_f",
    #groupColumn = "plys_f",
    #groupColumn = "topology_f",
    alpha = 0.1,
    showPoints = TRUE,
    title = graph.title
  ) + 
    geom_text(aes(legend=FALSE, x=2, y=0.05, label="H", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=2, y=0.55, label="R", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=2, y=1.05, label="Z", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=3, y=0.05, label="(1,1,1,1)", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=3, y=0.40, label="(2,2)", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=3, y=0.70, label="(3,1)", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=3, y=1.05, label="(4)", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=4, y=0.05, label="----", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=4, y=0.50, label="XY-T", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=4, y=0.60, label="XYZ-", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=4, y=0.70, label="XYZT", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=4, y=0.80, label="X-ZT", size=1), col="#000000", show_guide=FALSE) +
    geom_text(aes(legend=FALSE, x=4, y=1.05, label="-YZT", size=1), col="#000000", show_guide=FALSE)
  ggsave(filename=paste("/tmp/", graph.name, "-", dims, ".png", sep=""), width=width, height=height, units="in")
}


####################################################################
#
# MAIN PROGRAM
#
####################################################################

#compactness_vs_throughput()
#score.plot("adjusted", "adj.score")
#score.plot("raw", "score")
#range.study.plot(FALSE)
#range.study.plot(TRUE)
summary.parcoords(q4d, 11.0, 5)
